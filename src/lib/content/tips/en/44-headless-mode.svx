---
id: 44
title: "Headless Mode"
section: advanced
summary: "Run Claude without interactive session. For automation and scripts."
isFree: false
---

The `-p` flag turns Claude Code into a scriptable CLI tool. Add it to any command, and Claude executes once and exits. No interactive session, no prompts, just stdin/stdout. This is how you integrate Claude into shell scripts, pre-commit hooks, and automation pipelines.

```bash
claude -p "explain this error"
cat error.log | claude -p "what's causing this crash"
git diff | claude -p "review for bugs"
```

Claude Code follows Unix philosophy. Pipe data in, pipe results out, chain with other tools.

## Output Formats

The `--output-format` flag controls how Claude returns data. The [CLI reference](https://code.claude.com/docs/en/cli-reference) documents three options:

| Format | Use Case |
|--------|----------|
| `text` | Default human-readable output |
| `json` | Structured data with metadata for scripting |
| `stream-json` | Newline-delimited JSON for real-time processing |

For any automation, use `--output-format json`. It gives you the response text plus metadata you can parse with jq:

```bash
claude -p "analyze code quality" --output-format json | jq -r '.result'

# Capture session ID for multi-step workflows
session_id=$(claude -p "start review" --output-format json | jq -r '.session_id')
```

The JSON response includes `result` (the response text), `session_id`, and usage data you can use for cost tracking.

## Structured Output with JSON Schema

When you need guaranteed parseable output, use `--json-schema` to enforce a schema:

```bash
claude -p "Extract all TODO items from the codebase" \
  --output-format json \
  --json-schema '{
    "type": "object",
    "properties": {
      "todos": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "file": {"type": "string"},
            "line": {"type": "number"},
            "task": {"type": "string"}
          }
        }
      }
    }
  }' | jq '.structured_output.todos'
```

The response goes into `.structured_output` instead of `.result`. Claude uses constrained decoding to guarantee the output matches your schema.

## Tool Control

In headless mode, there's no one to click "approve." You need to pre-authorize tools with `--allowedTools`:

```bash
# Allow specific tools to run without prompting
claude -p "fix linting errors" --allowedTools "Read,Edit,Bash"

# Restrict Bash to specific commands with colon syntax
claude -p "create a commit" \
  --allowedTools "Bash(git diff:*),Bash(git log:*),Bash(git status:*),Bash(git commit:*)"
```

The colon syntax (`Bash(npm test:*)`) restricts Bash to that command and variants. Use this instead of blanket Bash access.

**`--disallowedTools`** does the opposite: it removes tools from Claude's context entirely. Use it when you want to guarantee Claude can't even attempt certain operations.

For read-only analysis, start minimal:

```bash
claude -p "analyze architecture" --allowedTools "Read,Grep,Glob"
```

## Execution Limits

The `--max-turns` flag prevents runaway operations. Each "turn" is one action Claude takes:

```bash
claude -p "refactor this module" --max-turns 10
claude -p "fix all type errors" --max-turns 5 --allowedTools "Read,Edit"
```

Without this, Claude can loop indefinitely on complex tasks. I set `--max-turns 10` as a default for most automation.

## Session Management

Headless mode supports multi-turn conversations across invocations:

```bash
# Continue most recent conversation
claude -p "now focus on security issues" --continue

# Resume specific session by ID
claude -p "continue the review" --resume "$session_id"
```

For multi-step pipelines, capture the session ID from the first call:

```bash
session_id=$(claude -p "Review this codebase for performance issues" --output-format json | jq -r '.session_id')
claude -p "Now focus on database queries" --resume "$session_id"
claude -p "Generate a summary of all issues found" --resume "$session_id"
```

Sessions persist locally but can expire. For long-running workflows, log the session ID somewhere you can retrieve it.

## System Prompts

Three flags for customizing Claude's behavior:

```bash
# Append to default system prompt (recommended)
gh pr diff "$PR_NUMBER" | claude -p "Review this diff" \
  --append-system-prompt "You are a security engineer. Focus on vulnerabilities."

# Replace system prompt entirely
claude -p "query" --system-prompt "You are a Python expert."

# Load from file
claude -p "query" --system-prompt-file ./prompts/security-review.txt
```

Prefer `--append-system-prompt`. It preserves Claude Code's built-in behaviors (tool usage, file handling) while adding your instructions. Replacing the system prompt entirely means you lose those defaults.

## Pre-Commit Hooks

Block commits that fail automated checks:

```bash
#!/bin/bash
# .git/hooks/pre-commit

result=$(git diff --cached | claude -p "Any API keys, passwords, or secrets exposed? Reply only YES or NO" --allowedTools "")
if [[ "$result" == *"YES"* ]]; then
  echo "Potential secrets detected. Commit blocked."
  exit 1
fi
```

Note `--allowedTools ""` passes an empty list, meaning Claude can only respond with text. No file access, no commands.

## Batch Processing

Process multiple files in a loop:

```bash
for file in $(find src -name "*.py"); do
  claude -p "Review $file for type hints and docstrings" \
    --allowedTools "Read" \
    --output-format json >> results.jsonl
done
```

For parallel execution:

```bash
find src -name "*.ts" | xargs -P 4 -I {} claude -p "Add JSDoc to {}" --allowedTools "Read,Edit"
```

Each parallel invocation is a separate Claude session. They don't share context.

## Fanning Out Pattern

For large-scale migrations, have Claude generate a task list first, then iterate:

```bash
tasks=$(claude -p "List all files that need React to Vue migration" --output-format json | jq -r '.result')

echo "$tasks" | while read file; do
  claude -p "Migrate $file from React to Vue. Return OK if succeeded, FAIL if failed" \
    --allowedTools "Read,Edit" \
    --max-turns 5
done
```

This pattern works well for codemod-style operations where you need Claude to analyze scope before executing.

## Environment Variables

```bash
# Required: API key
export ANTHROPIC_API_KEY="sk-..."

# Alternative providers
export CLAUDE_CODE_USE_BEDROCK=1  # Use AWS Bedrock
export CLAUDE_CODE_USE_VERTEX=1   # Use Google Vertex AI
```

You can also set these in `~/.claude/settings.json` under the `env` key for persistent configuration.

## Debugging

When headless invocations fail silently, add `--verbose`:

```bash
claude -p "query" --verbose
```

This shows every tool call and API request. Disable in production for cleaner logs.

## Sandboxing with --dangerously-skip-permissions

This flag bypasses all permission prompts. The name is intentional:

```bash
docker run -v $(pwd):/workspace \
  -e ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY \
  my-claude-image \
  claude --dangerously-skip-permissions -p "refactor the codebase"
```

Only use this in isolated containers without network access. It removes every safety check Claude Code has. Files get deleted, wrong directories get modified, and there's no confirmation step to catch mistakes.

For most automation, `--allowedTools` with a minimal tool list is safer and gives you the same unattended execution.

## Limitations

- **No slash commands:** `/commit`, `/review` etc. only work in interactive mode. Describe the task in your prompt instead.
- **No mid-task questions:** Claude can't ask for clarification. Your prompt needs to be unambiguous.
- **No interactive prompts:** Tools must be pre-approved with `--allowedTools`.
- **Sessions expire:** For workflows spanning hours or days, persist and validate session IDs.

## Best Practices

1. **Start read-only:** Begin with `--allowedTools "Read,Grep,Glob"` before enabling writes
2. **Use JSON output:** Always `--output-format json` for scripting
3. **Set max-turns:** Prevent runaway loops with `--max-turns`
4. **Restrict Bash:** Use colon syntax (`Bash(git:*)`) instead of blanket Bash access
5. **Append, don't replace:** Use `--append-system-prompt` to preserve defaults
6. **Capture session IDs:** Enable multi-step workflows by logging them

Headless mode is the bridge between Claude Code and everything else in your toolchain. Start with read-only operations, validate outputs before trusting them, and add write access only when you've seen Claude handle your specific task correctly.
