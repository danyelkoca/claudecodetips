---
id: 47
title: "Claude is Great at Boilerplate"
section: use-cases
summary: "CRUD operations, forms, config files, repetitive patterns. Let Claude grind."
isFree: false
---

Boilerplate is the best use case for Claude Code. CRUD endpoints, form components, config files, test scaffolding. Code you've written a hundred times that requires no creativity. Hand it off.

I've found that the less thinking a task requires, the better Claude performs. A REST endpoint with standard validation? Near-perfect output. A complex caching strategy? You'll spend more time fixing it than writing it yourself.

## Where Claude Excels

Claude handles predictable, structured code well:

**API scaffolding**: REST endpoints, GraphQL resolvers, Express/Fastify middleware, request/response DTOs. Give it an existing route file and tell it to follow the pattern.

**Forms**: React Hook Form with Zod, validation schemas, error handling, accessibility attributes. Forms are formulaic. That's the point.

**Database models**: Prisma schemas, TypeORM entities, migrations. The structure follows conventions. Claude knows these conventions.

**Config files**: GitHub Actions workflows, Docker Compose, ESLint/Prettier setups, tsconfig.json. These are documented, standardized formats.

**Test scaffolding**: Describe blocks, mock setup, fixture generation, happy path stubs. The structure is predictable even when the assertions aren't.

## The Critical Rule: Reference Existing Code

Never let Claude invent patterns. The single most effective technique for boilerplate generation:

```
Read src/routes/users.ts first.
Generate src/routes/products.ts following the exact same patterns.
Same validation approach, same error handling, same response format.
```

Claude Code can read your codebase. Use that. When you reference existing files, it copies your project's conventions instead of inventing generic ones. I've seen the difference between "generate a CRUD endpoint" (mediocre) and "follow the pattern in users.ts" (nearly production-ready).

## Prompt Structure That Works

Skip vague requests. Be explicit:

```
Generate Express CRUD routes for a "comments" resource:
- GET /comments (list with pagination)
- GET /comments/:id
- POST /comments
- PUT /comments/:id
- DELETE /comments/:id

Use async/await, Zod validation, and Prisma.
Follow patterns in src/routes/posts.ts exactly.
```

For forms:

```
Create a React registration form:
- Fields: email, password, confirmPassword, name
- Use react-hook-form with Zod
- Match validation patterns in src/components/LoginForm.tsx
- Same error message styling
```

For test files:

```
Generate Jest test boilerplate for src/services/PaymentService.ts.
- Describe blocks for each public method
- Mock Stripe client following src/services/__tests__/OrderService.test.ts
- Happy path and error case stubs only. I'll fill in assertions.
```

The pattern: specify the structure, reference existing files, set boundaries on what you'll handle yourself.

## Set Clear Boundaries

Tell Claude what you're delegating and what you're keeping:

```
Generate the class skeleton and type definitions.
I'll implement processPayment() myself.
Just the structure, no business logic.
```

This prevents Claude from generating speculative logic that you'll delete anyway. Boilerplate means structure, not implementation.

## Security: Review Everything

[Veracode's 2025 research](https://www.helpnetsecurity.com/2025/08/07/create-ai-code-security-risks/) found that LLMs introduce security vulnerabilities in 45% of code samples. Java had failure rates above 70%. The common issues: missing input validation, XSS vectors, log injection, improper error exposure.

This doesn't mean avoid AI-generated code. It means treat it as a first draft. For boilerplate specifically:

- Check input validation is actually present, not just mentioned
- Verify error messages don't leak stack traces or internal paths
- Confirm auth checks aren't stubbed out
- Test edge cases Claude might have skipped

Boilerplate feels safe because it's boring. That's exactly when you miss the SQL injection in the search endpoint.

## What Doesn't Work

Claude struggles when boilerplate stops being boilerplate:

**Custom business logic**: "Generate a pricing calculator based on our discount rules." Claude doesn't know your rules. It'll invent plausible-looking logic that's completely wrong.

**Security-critical flows**: Auth token generation, password hashing, encryption. Use battle-tested libraries and write the integration yourself.

**Performance-sensitive code**: Database query optimization, caching strategies, connection pooling. These require understanding your data patterns, not just generating code.

**Novel architecture**: Don't ask Claude to design your system. It'll produce something that looks reasonable but doesn't fit your constraints.

The dividing line: if you've done it dozens of times, delegate it. If it requires judgment about your specific situation, keep it.

## The Productivity Reality

The research on AI coding productivity is mixed. [A rigorous METR study](https://metr.org/blog/2025-07-10-early-2025-ai-experienced-os-dev-study/) found experienced developers actually took 19% longer with AI tools on complex tasks, despite believing they were 24% faster. Developer perception doesn't match reality.

But that study measured complex, judgment-heavy work. Boilerplate is different. According to [JetBrains' 2025 developer survey](https://blog.jetbrains.com/research/2025/10/state-of-developer-ecosystem-2025/), nearly 90% of developers save at least an hour weekly with AI tools, and the top use case is "writing boilerplate, repetitive code."

The pattern: boilerplate saves time because there's nothing to get wrong. Complex logic loses time because you spend it reviewing, debugging, and rewriting. Know which task you're doing.

## A Real Example

Last week I needed CRUD endpoints for five new resources. Same pattern, same validation, same error handling. Without Claude, that's a half-day of copy-paste-modify tedium. With Claude:

```
Read src/routes/users.ts.
Generate the same pattern for these resources:
- products
- orders
- reviews
- categories
- inventory

Each resource gets: list with pagination, get by id, create, update, delete.
Same Zod schemas, same Prisma queries, same error responses.
```

Twenty minutes, five files, minimal edits. That's where Claude shines. I kept the interesting work: the complex order state machine, the inventory sync logic, the pricing calculations.

Boilerplate is Claude's home turf. Let it grind while you focus on the problems that actually require your brain.
