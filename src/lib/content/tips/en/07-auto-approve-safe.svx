
Claude asks permission for every action by default. This kills momentum. You ask Claude to refactor a component, check email, grab coffee, and return to find Claude sitting idle, waiting to ask if it can read the exact file you told it to analyze.

The constant interruption does more than annoy you. It trains you to click "approve" without looking. [Anthropic's engineering team](https://www.anthropic.com/engineering/claude-code-sandboxing) calls this "approval fatigue" and found that sandboxing alone reduces permission prompts by 84%. But even without sandboxing, you can dramatically speed up your workflow by auto-approving genuinely safe operations.

## How Claude Code Permissions Work

Claude Code uses a tiered permission system with three rule types:

- **Allow**: Automatically approves matching operations without prompts
- **Deny**: Completely blocks operations; always overrides allow rules
- **Ask**: Forces confirmation prompts for specific actions

When Claude asks for permission, you can select "Always allow" to add the action to your allowlist. This creates entries in `.claude/settings.local.json`:

```json
{
  "permissions": {
    "allow": [
      "Read",
      "Glob",
      "Grep",
      "WebSearch",
      "WebFetch(domain:docs.anthropic.com)",
      "WebFetch(domain:developer.mozilla.org)"
    ]
  }
}
```

## Configuration File Hierarchy

[Settings are applied](https://code.claude.com/docs/en/settings) in this order (highest to lowest priority):

1. **Enterprise policies** (`managed-settings.json`) - Cannot be overridden
2. **Command line arguments** - Temporary session overrides
3. **Local project settings** (`.claude/settings.local.json`) - Personal, git-ignored
4. **Shared project settings** (`.claude/settings.json`) - Team-shared, version controlled
5. **User settings** (`~/.claude/settings.json`) - Global defaults

Local settings are automatically gitignored. Use them for personal preferences without affecting your team.

## Safe to Auto-Approve

These operations are read-only and cannot modify your system:

### Read Operations

- `Read` - File reading poses no risk to your system
- `Glob` - Pattern matching to find files by name
- `Grep` - Searching file contents for patterns
- `LS` - Listing directory contents

[Claude Code's Explore subagent](https://code.claude.com/docs/en/sub-agents) operates in strict read-only mode using only these tools. If it's safe enough for autonomous exploration, it's safe for auto-approval.

### Web Operations

- `WebSearch` - Searching the web is read-only; returns links without fetching content
- `WebFetch(domain:trusted-site.com)` - Fetching from specific documentation sites

For WebFetch, scope to specific trusted domains:

```json
{
  "permissions": {
    "allow": [
      "WebFetch(domain:docs.anthropic.com)",
      "WebFetch(domain:developer.mozilla.org)",
      "WebFetch(domain:react.dev)",
      "WebFetch(domain:svelte.dev)"
    ]
  }
}
```

Domain matching is exact. `WebFetch(domain:example.com)` won't match `www.example.com`. Add both if the site uses both.

### Read-Only Bash Commands

Some bash commands are inherently safe because they only read information:

```json
{
  "permissions": {
    "allow": [
      "Bash(git status)",
      "Bash(git diff:*)",
      "Bash(git log:*)",
      "Bash(pwd)",
      "Bash(echo:*)",
      "Bash(date)",
      "Bash(which:*)"
    ]
  }
}
```

Bash permissions use prefix matching, not regex. `Bash(git diff:*)` matches `git diff`, `git diff HEAD`, etc.

## Never Auto-Approve

### Bash Commands

The `Bash` tool can execute anything with your full user permissions. A single auto-approved `curl` or `wget` can exfiltrate credentials via prompt injection. Stick to the read-only commands listed above.

### Write Operations

- `Write` - Creates or overwrites entire files
- `Edit` - Makes targeted edits to existing files
- `MultiEdit` - Batch edits across files
- `NotebookEdit` - Modifies Jupyter notebooks

Review the diff before approving. Every time.

### MCP Tools

MCP servers give Claude access to external services. Only enable servers you understand. If you don't know what an MCP server does, don't enable it.

## Hands-Off Research Workflows

With read operations pre-approved, Claude researches without stopping to ask. You only intervene for actual changes.

Press `Shift+Tab` to cycle through [permission modes](https://code.claude.com/docs/en/interactive-mode). The cycle goes: Normal > Auto-accept edits > Plan mode > back to Normal. Here's what hands-off research looks like:

> "Research how authentication works in this codebase. Read all relevant files, search for patterns, trace the flow from login to session creation."

Claude will autonomously read dozens of files, grep for patterns, and explore the codebase without a single permission prompt. When it's ready to propose changes, only then do you review.

## Custom Approval Logic with Hooks

For dynamic control beyond static rules, use [PreToolUse hooks](https://code.claude.com/docs/en/hooks):

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [{ "type": "command", "command": "./validate-bash.sh" }]
      }
    ]
  }
}
```

Your script receives the full tool call as JSON via stdin. Exit 0 to allow, exit 2 to block (with stderr message shown to Claude). Or return JSON with `"permissionDecision": "allow"`, `"deny"`, or `"ask"`.

Example: auto-approve `npm run` but block any command containing `rm` or `curl`. The hook runs before Claude executes, so you can enforce rules that static patterns can't express.

## The Balance

The goal is not to approve everything. It's to approve the operations that genuinely cannot cause harm, so you can focus your attention on the ones that can.

A well-configured permission setup:
- Pre-approves all read operations
- Pre-approves web fetches from trusted documentation sites
- Requires review for all file modifications
- Requires review for all bash commands except known-safe ones

This gives you the speed of agentic workflows with the safety of human oversight where it matters.

## Quick Setup

Add this to your `~/.claude/settings.json` as a starting point:

```json
{
  "permissions": {
    "allow": [
      "Read",
      "Glob",
      "Grep",
      "LS",
      "WebSearch",
      "WebFetch(domain:docs.anthropic.com)",
      "WebFetch(domain:developer.mozilla.org)",
      "Bash(git status)",
      "Bash(git diff:*)",
      "Bash(git log:*)",
      "Bash(npm run lint)",
      "Bash(npm run test:*)"
    ],
    "deny": [
      "Bash(curl:*)",
      "Bash(wget:*)",
      "Bash(rm:*)",
      "Bash(sudo:*)"
    ]
  }
}
```

Use `/permissions` in Claude Code to review and refine as you work. The interactive UI makes it easy to add or remove tools from your allowlist without editing JSON.

## Sandboxing: The Next Level

If pre-approvals aren't enough, [sandboxing](https://code.claude.com/docs/en/sandboxing) takes it further. Run `/sandbox` in Claude Code to enable filesystem and network isolation at the OS level. Claude can then run bash commands freely within defined boundaries. No permission prompts, no risk of escaping the sandbox.

Sandboxing uses Linux bubblewrap or macOS seatbelt to enforce restrictions. Even if Claude gets prompt-injected, it can't modify files outside your working directory or connect to unauthorized servers. The 84% reduction in permission prompts comes from this approach.
