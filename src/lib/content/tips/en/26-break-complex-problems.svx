
A project has 47 prefectures. Ask Claude to evaluate data sources across all 47 in one shot? It fails. It starts making assumptions, loses track of which prefecture it analyzed, confuses data from one with another, and produces an incoherent mess. But one session per prefecture? Works perfectly every time.

This is not a bug. It's how the architecture works.

## Why Complex Tasks Fail

[Research from Stanford (Liu et al., 2023)](https://arxiv.org/abs/2307.03172) demonstrated that LLM performance follows a U-shaped curve. Models perform best when relevant information appears at the very beginning or very end of the context. Information in the middle gets increasingly ignored. In practical terms: Claude remembers your initial instructions and your most recent message. Everything between becomes fuzzy.

[Chroma's context rot research](https://research.trychroma.com/context-rot) showed this isn't just theoretical. When testing 18 major LLMs including Claude 4, performance consistently degraded as input length increased, even on simple tasks. The effect compounds: lower similarity between questions and answers causes sharper decline with longer inputs.

There's also an architectural constraint. Transformer attention scales quadratically with sequence length. As your session grows, the model must attend to exponentially more token relationships. Quality suffers.

## The Core Principle

**One sub-task = one focused session.**

Break complex work into independently completable and verifiable pieces. Each piece should:
- Fit comfortably in a fresh context window
- Have clear success criteria
- Produce a reviewable, committable result
- Not depend on accumulated conversational context

Break before you start, not when you're stuck. If you wait until Claude is confused, you've already wasted time and tokens.

## Task Categories

Not all tasks require decomposition. Understanding the categories helps you decide:

**Type 1: Narrow Tasks.** Feature flag removal, unit tests for a single function, boilerplate code generation. Claude excels at these. No breakdown needed.

**Type 2: Context-Dependent Tasks.** Debugging a specific error, refactoring code to match existing patterns. Requires understanding existing code but still focused. Usually fine in one session.

**Type 3: Open-Ended Tasks.** "Build user authentication" or "Implement the payment system" or "Migrate the codebase to TypeScript." These must be broken down first. Attempting them in one shot virtually guarantees poor results.

## Decomposition Strategies

### Linear Decomposition

Sequential steps where each depends on the previous:

```
1. Create auth types and interfaces
2. Implement token generation
3. Add login endpoint
4. Add session middleware
5. Create protected routes
6. Add logout flow
```

Complete step 1, commit, `/clear`, then step 2. Each step gets a fresh context.

### Modular Decomposition

Independent pieces that combine later:

```
- Component A (can be built standalone)
- Component B (can be built standalone)
- Integration layer (combines A and B)
```

These can run in parallel. You could use multiple terminal windows or git worktrees with separate Claude sessions.

### Recursive Decomposition

If a sub-task is still too complex, break it further:

```
"Implement user authentication"
  └── "Implement login flow"
        └── "Validate email format"
        └── "Hash password with bcrypt"
        └── "Generate JWT token"
        └── "Store refresh token"
```

Keep breaking until each piece is small enough that Claude can complete it in a single focused session.

## Practical Techniques

### Markdown Checklist as Working Memory

For large tasks like code migrations or fixing numerous lint errors, use a markdown file as external memory:

```markdown
## Migration Tasks
- [x] Update component Header
- [x] Update component Footer
- [ ] Update component Sidebar
- [ ] Update component Modal
- [ ] Run tests
- [ ] Fix any failures
```

Have Claude update this file as it works. This checklist survives `/clear` commands and session restarts. Claude can always check what's done and what remains.

### The Document-and-Clear Pattern

For complex multi-session work:

```bash
# Before clearing
"Write your current progress, key decisions made, and next steps to progress.md"

# Clear the session
/clear

# Resume in fresh session
"Read progress.md and continue from where we left off"
```

This creates durable external memory that persists across context resets. The nuanced understanding that would be lost in automatic compaction is preserved in the document.

### Fanning Out at Scale

For truly large-scale work (47 prefectures, 1000 files, etc.), use [headless mode](https://code.claude.com/docs/en/headless) to process items programmatically:

```bash
# Generate task list
claude -p "List all 47 prefecture names, one per line" > prefectures.txt

# Process each
while read prefecture; do
  claude -p "Analyze data sources for $prefecture. Output to results/$prefecture.md"
done < prefectures.txt
```

Each invocation gets a fresh context. No cross-contamination between prefectures.

This pattern works for any batch operation: migrating files, generating reports, running analyses across datasets. The key is isolating each unit of work.

### External State Files

The built-in todo list does not persist across sessions. Use external files:

- `plan.md` - Implementation plan with checkboxes
- `progress.md` - What's done, what's next
- `decisions.md` - Key architectural decisions made

Claude can read and update these across sessions. They become your project's working memory.

## Signs Your Task is Too Big

| Symptom | What It Means |
|---------|---------------|
| Claude starts making assumptions | Context overloaded, losing track of details |
| Responses become generic | Lost specificity, reverting to defaults |
| Same mistakes repeat | Earlier corrections pushed out of context |
| Claude goes in circles | Confused about state, trying old solutions |
| Asks questions you answered | Instruction amnesia from context overflow |

When you see these, stop. Don't push forward. Clear the session. Break the task smaller. Resume with focused sub-tasks.

## Real-World Examples

### Code Migration

**Bad approach:**
> "Migrate all 500 components from Ember to React"

**Good approach:**
1. Migrate form components (10 files)
2. Migrate modal components (8 files)
3. Migrate layout components (12 files)
4. ...continue by category

Each batch is its own session. Each produces a reviewable PR. You can spot problems early instead of discovering 500 broken components at once.

### Multi-File Feature

**Bad approach:**
> "Implement user authentication with OAuth, JWT, session management, and social login"

**Good approach:**
1. Session 1: Create auth types and interfaces
2. Session 2: Implement JWT token generation and validation
3. Session 3: Add login endpoint
4. Session 4: Add session middleware
5. Session 5: Create protected route wrapper
6. Session 6: Add logout flow
7. Session 7: Add OAuth provider integration
8. Session 8: Add social login buttons

Each session has clear scope. Each produces testable code. If session 4 breaks something from session 3, you catch it immediately.

### Bulk Analysis

**Bad approach:**
> "Evaluate data quality across all 47 prefectures and generate recommendations"

**Good approach:**
- One session per prefecture
- Each session outputs to `analysis/prefecture-name.md`
- Final session aggregates all 47 reports into summary

No single session needs to hold 47 analyses in context.

## Let Claude Do the Decomposition

Claude is excellent at breaking down tasks. Start a session specifically for planning:

```bash
claude -p "I need to implement user authentication. Break this into
implementable sub-tasks. Each should be completable in a single focused session.
Output as a markdown checklist."
```

Claude generates the task list. You then execute each task in its own session with `/clear` between them.

For migrations, have Claude scan your codebase first:

```bash
claude -p "Generate a markdown checklist for migrating this codebase from JavaScript
to TypeScript. Group by directory. Each checkbox should be one file or small group."
```

Use the generated checklist as your working memory file.

## The Decomposition Mindset

Think of Claude like a contractor you're giving work orders to. You wouldn't hand a contractor a single work order that says "build the entire house." You'd break it into: foundation, framing, electrical, plumbing, drywall, finishing.

Each work order has:
- Clear scope ("install electrical in the kitchen")
- Defined completion criteria ("all outlets wired, breaker panel labeled")
- A way to verify success ("inspection passes")

Same principle applies here. "Implement the payment system" is not a work order. "Add Stripe checkout endpoint that creates a session and returns the URL" is.

## Key Takeaways

Complex tasks fail not because Claude is incapable, but because the task overwhelms context management. The solution is simple: decompose.

Break before you start. Planning the decomposition upfront is faster than recovering from a confused session.

Each sub-task should produce a reviewable, testable result before moving on. Commit frequently. If something breaks, you know exactly which session caused it.

Treat Claude like a focused specialist, not an omniscient oracle. Give it one clear job at a time, and it will excel. Ask it to juggle everything at once, and it will drop the balls.
