
Codebases rot. Inconsistencies creep in, technical debt compounds, and what was once clean architecture becomes a tangled mess. Claude Code is perfect for periodic quality audits, but you need realistic expectations about what it catches and what slips through.

## The Built-in Security Review

Claude Code ships with a [`/security-review` command](https://support.claude.com/en/articles/11932705-automated-security-reviews-in-claude-code) that scans your codebase for common vulnerabilities. Run it before major commits:

```
/security-review
```

It checks for SQL injection, XSS, authentication flaws, insecure data handling, and dependency vulnerabilities. For teams, there's a [GitHub Action](https://github.com/anthropics/claude-code-security-review) that triggers on every PR.

But here's the reality: [Semgrep's security research](https://semgrep.dev/blog/2025/finding-vulnerabilities-in-modern-web-apps-using-claude-code-and-openai-codex/) found Claude Code achieves about 14% true positive rate on security scans, with 86% false positives. Performance varies wildly by vulnerability type: 22% for IDOR bugs, but just 5% for SQL injection. The model struggles to trace data across multiple files.

This means: use `/security-review` as a first pass, not your only defense. Pair it with traditional SAST tools like Semgrep or SonarQube for production code. Human review remains non-negotiable for anything touching authentication, payments, or user data.


## Internationalization (i18n) Audits

Hardcoded strings are time bombs. They make localization impossible and create maintenance nightmares.

**Hardcoded string detection:**

```
Find all hardcoded user-facing strings in the codebase. Check:
- UI components for text not wrapped in translation functions
- Error messages passed directly to users
- Email templates with hardcoded content
- Placeholder text that should be localized
Exclude: log messages, code comments, internal identifiers.
```

**Missing translation keys:**

```
Compare the translation files across all supported languages.
Find any keys that exist in the primary language but are missing
in other language files. List missing keys by language.
```

**Unused i18n strings:**

```
Find all translation keys that are defined but never used in the
codebase. Check the translation files against actual usage in
components and pages. List orphaned keys that can be removed.
```

I run these i18n checks after every major feature ships. Translations are expensive. Finding 50 orphaned keys before sending to translators saves real money.


## Technical Debt Detection

Technical debt compounds with interest. Small shortcuts today become massive refactoring projects tomorrow.

**Dead code identification:**

```
Find all dead code in this codebase:
- Unused functions, classes, and methods
- Unreachable code blocks (after returns, inside false conditions)
- Commented-out code blocks
- Unused imports and dependencies
- Files that are never referenced
List everything that can be safely removed.
```

**Code duplication analysis:**

```
Find duplicated logic across the codebase. Look for:
- Copy-pasted functions with minor variations
- Similar API call patterns that could be abstracted
- Repeated validation logic
- Duplicated utility functions across modules
For each duplication, note locations and suggest consolidation.
```

**Complexity hotspots:**

```
Identify the most complex functions in this codebase. Find:
- Functions over 50 lines
- Deeply nested conditionals (3+ levels)
- Functions with many parameters (5+)
- High cyclomatic complexity areas
Rank by severity and suggest refactoring priorities.
```

**Outdated dependencies:**

```
Check all dependencies for:
- Packages with known security vulnerabilities
- Major version updates available
- Deprecated packages that need replacement
- Unused dependencies that can be removed
Run npm audit (or equivalent) and explain findings.
```

For dead code and duplication, Claude's analysis is directional, not definitive. It might flag a function as unused when it's called dynamically. Always verify before deleting. But even with false positives, these scans surface candidates you'd never find manually.


## Caching Consistency

Inconsistent caching causes mysterious bugs. Users see stale data while developers scratch their heads.

**Cache pattern audit:**

```
Review all caching implementations. Check for:
- Consistent TTL values for similar data types
- Proper cache invalidation on data mutations
- Cache key naming conventions
- Mix of caching strategies (cache-aside, write-through)
Flag any endpoints with inconsistent caching behavior.
```


## API Consistency

Inconsistent APIs confuse consumers and create integration bugs.

**Endpoint pattern audit:**

```
Audit REST API endpoints for consistency:
- Naming: plural nouns, consistent casing, no verbs in paths
- HTTP methods: proper use of GET/POST/PUT/DELETE
- Status codes: consistent error responses (404 for not found everywhere)
- Request/response schemas: same field naming patterns
- Pagination: consistent approach across list endpoints
List all violations of the established patterns.
```

