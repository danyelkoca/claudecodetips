
Custom slash commands encode repeatable workflows as Markdown files. Drop a `.md` file in the right folder, and it becomes a command you invoke with `/command_name`. No typing detailed instructions each time.

## Where Commands Live

[Two storage locations](https://code.claude.com/docs/en/slash-commands) determine scope:

**Project Commands** in `.claude/commands/`:
```bash
.claude/commands/review.md      # /project:review
.claude/commands/fix-issue.md   # /project:fix-issue
```

**Personal Commands** in `~/.claude/commands/`:
```bash
~/.claude/commands/security.md  # /user:security
```

Project commands override personal commands with the same name. Type `/` in Claude Code to see all available commands, including which scope each belongs to.

## Basic Structure

The filename minus `.md` becomes the command name:

```markdown
<!-- .claude/commands/review.md -->

Review this code for:
1. SQL injection, XSS, and authentication bypasses
2. N+1 queries and missing indexes
3. Null pointer risks and unhandled edge cases
4. Violations of our style guide

For each issue, show the problematic code and a fix.
```

Invoke with `/project:review`. That's it.

## Dynamic Values with $ARGUMENTS

The `$ARGUMENTS` placeholder captures everything after the command:

```markdown
<!-- .claude/commands/fix-issue.md -->

Analyze and fix GitHub issue: $ARGUMENTS

1. Run `gh issue view $ARGUMENTS` to get details
2. Search codebase for relevant files
3. Implement the fix
4. Write tests covering the fix
5. Run lint and type checks
```

`/project:fix-issue 1234` passes "1234" as the argument. `/project:fix-issue 1234 urgent` passes "1234 urgent" as a single string.

## Positional Arguments

For commands that need discrete values, use `$1`, `$2`, `$3`:

```markdown
<!-- .claude/commands/compare-branches.md -->

Compare $1 with $2.

1. Run `git log $1..$2 --oneline` to see commits
2. Run `git diff $1...$2 --stat` for file changes
3. Summarize what changed and potential risks
```

`/project:compare-branches main feat/auth` sets `$1` to "main" and `$2` to "feat/auth".

## Frontmatter Options

Optional YAML frontmatter controls behavior:

```markdown

Create a git commit with message: $ARGUMENTS
```

| Field | Purpose |
|-------|---------|
| `allowed-tools` | Tools the command can use. Format: `Bash(npm:*)`, `Read`, `Edit`, etc. |
| `argument-hint` | Shown in autocomplete. Use `[required]` and `(optional)` conventions. |
| `description` | Brief text shown in `/help` output. |
| `model` | Specific model ID. Inherits from conversation if not set. |
| `disable-model-invocation` | Set to `true` to prevent automatic invocation by the SlashCommand tool. |

For `allowed-tools`, you can specify exact commands: `Bash(git add:*)` allows only `git add` commands. `Bash(git:*)` allows any git subcommand. If your command runs bash but you don't specify `allowed-tools`, it won't have permission to execute.

## Bash Execution with !

Prefix shell commands with `!` to run them before Claude sees the prompt. The output gets injected into the prompt:

```markdown

## Current State

- Status: !`git status --short`
- Staged diff: !`git diff --staged`
- Branch: !`git branch --show-current`
- Recent commits: !`git log --oneline -5`

## Task

Based on the staged changes above, create a commit following conventional commit format.
```

This is what makes commands context-aware. Claude sees the actual output of `git status`, not just instructions to run it.

## File References with @

Include file contents directly with `@`:

```markdown
Compare the implementations in:
- @src/old-version.js
- @src/new-version.js

Identify breaking changes and write migration steps.
```

Claude reads both files before processing. Combine with `$ARGUMENTS` for dynamic file references:

```markdown
<!-- .claude/commands/explain.md -->
Review @$ARGUMENTS and explain:
1. What it does
2. Key design decisions
3. Potential improvements
```

`/project:explain src/auth/login.ts` explains that specific file.

## Practical Examples

### Git Automation

**Branch creation** (`.claude/commands/branch.md`):
```markdown

!`git status --short`
!`git branch --show-current`

Create a feature branch for: $ARGUMENTS

1. Stash any uncommitted changes
2. Checkout main and pull latest
3. Create branch: feat/kebab-case-description
4. Push with -u to set upstream
5. Pop stash if anything was stashed
```

**Smart commit** (`.claude/commands/commit.md`):
```markdown

!`git diff --staged`
!`git log --oneline -5`

Generate a conventional commit message that matches the style of recent commits.
Stage, commit, but don't push.
```

### Code Quality

**Test runner** (`.claude/commands/test.md`):
```markdown

!`npm test 2>&1 | head -100`

Fix any failing tests by updating the IMPLEMENTATION, not the test.
Tests define expected behavior. If a test fails, the code is wrong.
```

**Lint and fix** (`.claude/commands/lint.md`):
```markdown

!`npm run lint 2>&1`

Fix all linter errors. Do NOT disable rules. Do NOT modify test files.
If a rule seems wrong, fix the code to comply anyway.
```

### Security Audit

```markdown
<!-- ~/.claude/commands/security.md -->

Scan the codebase for:
- SQL injection (string concatenation in queries)
- XSS (unescaped user input in HTML)
- Hardcoded secrets (API keys, passwords, tokens)
- Insecure dependencies (check package.json)
- Auth bypasses (missing middleware, weak checks)

For each finding:
1. File and line number
2. Severity (critical/high/medium/low)
3. Exact vulnerable code
4. Fixed code
```

## Model Selection

Haiku runs fast and cheap. For simple, mechanical tasks, there's no reason to burn tokens on Sonnet:

```markdown
```

Use Haiku for:
- Linting and formatting
- Git operations (branch, commit, status)
- Running tests and reporting results
- Boilerplate generation

Use Sonnet (the default) for:
- Complex debugging
- Architecture decisions
- Code review with nuance
- Security analysis

Current model IDs as of Jan 2026:
- `claude-haiku-4-5-20251001` (fast)
- `claude-sonnet-4-5-20250929` (balanced)
- `claude-opus-4-5-20251101` (max capability)

You can also use aliases like `haiku`, `sonnet`, `opus` in most contexts.

## Organization Patterns

Put related commands in subdirectories for readability:

```
.claude/commands/
  git/
    branch.md
    commit.md
    pr.md
  test/
    unit.md
    e2e.md
  review/
    security.md
    perf.md
```

**Important caveat**: The [documented behavior](https://github.com/anthropics/claude-code/issues/2422) of subdirectory namespacing (`/project:git:branch`) doesn't work reliably. Commands in subdirectories often appear with just their filename (e.g., `/project:branch`). The subdirectory helps you organize files, but don't rely on the namespace syntax for invocation.

## Team Sharing

Commands in `.claude/commands/` get committed to git. When teammates clone, they inherit:
- Your team's standardized workflows
- Institutional knowledge baked into prompts
- Consistent quality checks

New developers run `/project:setup` on day one instead of reading a wiki nobody updates.

## Non-Interactive Execution

You can invoke custom slash commands with the `-p` flag:

```bash
claude -p '/project:lint'
claude -p '/project:commit'
```

This runs the command without the interactive UI. Works for project and user commands, not built-in ones like `/compact` or `/clear`.

## Common Mistakes

**Too generic**: "Review this code" tells Claude nothing. Include specific checklists, file patterns to check, and output formats.

**Missing context**: Without `!` commands, Claude doesn't know the current state. A commit command without `!git diff --staged` is guessing what changed.

**Wrong model for the job**: Using the default model for `git status` burns tokens and time. Use Haiku.

**No tool permissions**: Your command runs `npm test` but you didn't specify `allowed-tools: Bash(npm:*)`. Claude can't execute it.

**Too many positional args**: More than 3 positional arguments becomes impossible to remember. Use `$ARGUMENTS` and parse naturally instead.
