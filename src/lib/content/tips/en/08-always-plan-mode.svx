---
id: 8
title: "Always Use Plan Mode"
section: planning
summary: "Press Shift+Tab twice to enter plan mode before complex tasks. Claude thinks before coding."
isFree: false
---

Plan mode separates research from execution. Press `Shift+Tab` twice to activate it. You'll see `plan mode on` at the bottom of your terminal. Press again to exit.

In plan mode, Claude operates read-only. It explores your codebase, analyzes dependencies, searches patterns, and formulates strategies. But it can't edit files, run commands, or make changes until you approve the plan.

This separation matters because Claude tends to start coding before understanding the problem. Plan mode forces it to build context first.

**Available in plan mode:**
- Read files and directory listings
- Search with Glob and Grep
- Web search and research
- Spawn read-only subagents (Explore agent)
- Create and edit plan files

**Blocked until approval:**
- File edits and creation
- Command execution
- Git operations
- Any system modifications

## Why Plan Mode Matters

Most developers prompt Claude and expect immediate code. This works for trivial changes. For anything spanning multiple files or touching existing systems, it fails.

Plan mode forces the workflow senior engineers actually use: read existing code, understand the problem space, identify patterns, then build. Claude follows the same pattern when you make it plan first.

**In practice:**

- **Surfaces hidden complexity**: When Claude articulates the full solution upfront, you catch the "simple" features that would balloon into major refactors.
- **Catches integration issues**: Database changes, API modifications, and dependency conflicts get identified before implementation.
- **Cheaper iteration**: Changing a plan costs nothing. Changing code costs time and introduces bugs.
- **Alignment**: You and Claude agree on strategy before files change. Assumptions surface early.

## When to Use Plan Mode

**Multi-file changes**: Anything touching more than 2-3 files benefits from coordinated planning. Claude maps all affected files before touching any of them.

**New features**: Before building something new, Claude analyzes where it fits in your architecture, what patterns to follow, and what edge cases exist.

**Refactoring**: Library migrations, architecture shifts, and large-scale changes need a complete strategy visible before you commit to it.

**Unfamiliar codebases**: Claude researches thoroughly without risk of accidental changes. I use plan mode whenever I'm exploring a codebase I didn't write.

## When to Skip Plan Mode

**One-file edits**: Typo corrections, small bug fixes, or changes isolated to a single file don't need formal planning.

**Mechanical work**: Code formatting, boilerplate generation, or repetitive patterns need execution, not strategy.

## The Plan Mode Workflow

**Step 1: Activate and describe**

```bash
# Press Shift+Tab twice, then:
> I need to add OAuth2 authentication. Analyze the current auth system and create a migration plan.
```

**Step 2: Review the plan**

Claude reads relevant files, identifies patterns, and presents a structured plan. A good plan names specific files, functions, and the order of changes. If Claude gives you vague bullets like "update the auth module," push back.

**Step 3: Approve and execute**

Exit plan mode with `Shift+Tab`. Claude asks for confirmation about what it's about to do. This extra prompt is your last chance to catch misunderstandings before execution begins.

## Plan Mode with Extended Thinking

Add `ultrathink` to your planning prompts for complex architectural decisions:

```bash
> ultrathink. Analyze this authentication system and propose a refactoring plan.
```

Extended thinking allocates more reasoning tokens to the planning phase, where deep analysis has the highest payoff. The read-only safety of plan mode combined with maximum thinking budget catches issues you'd otherwise discover mid-implementation.

## Persisting Plans

Claude writes plans to `~/.claude/` by default, but these aren't automatically loaded in new sessions. For plans you want to reference later, save them to your project:

```bash
> Save this plan to .claude/PLAN.md
```

Files in `.claude/` can be referenced using `@.claude/PLAN.md` syntax in your prompts, or imported into CLAUDE.md. This gives you:
- Manual review and editing before execution
- Version control history
- Reference in future sessions via explicit import
- Sharing with team members

For multi-day features, keep the plan in your repo. When you resume work, point Claude at it:

```bash
> Read @.claude/PLAN.md and continue from where we left off.
```

## Opus Plan Mode

[Opus Plan Mode](https://code.claude.com/docs/en/model-config) uses Opus 4.5 for planning and Sonnet 4.5 for execution:

```bash
/model opusplan
```

Or start a session with it:

```bash
claude --model opusplan
```

Opus handles the research and architecture. When you exit plan mode, it hands off to Sonnet for implementation. You get Opus-quality thinking where it matters most, without paying for Opus-speed execution on straightforward coding.

## Common Mistakes

**Planning too much at once**: Plan what you can execute in one session. Large plans drift during execution. If your plan has 15 steps, break it into 3 smaller plans.

**Treating plans as final**: Plans are hypotheses. Expect to adjust once you start implementing and discover things Claude missed.

**Plan mode for trivial work**: If the change is obvious and isolated, skip the ceremony. Plan mode adds overhead. Use it for complexity, not compliance.

## Starting in Plan Mode

Start a session in plan mode from the command line:

```bash
claude --permission-mode plan
```

Or run a one-off analysis without an interactive session:

```bash
claude --permission-mode plan -p "Analyze the authentication system and identify security gaps"
```

To make plan mode your default, add to [`.claude/settings.json`](https://code.claude.com/docs/en/settings):

```json
{
  "permissions": {
    "defaultMode": "plan"
  }
}
```

This applies to all sessions in the project. Claude still needs your approval to exit plan mode and start executing.

## The Bottom Line

For anything beyond a single-file fix, use plan mode. The extra few seconds activating it prevents the multi-hour rework sessions that happen when Claude starts coding before it understands the problem.

The workflow I use: `Shift+Tab` twice, describe what I need, review the plan, then `Shift+Tab` to execute. When the plan is solid, execution is fast. When I skip planning, I spend twice as long fixing the mess.
