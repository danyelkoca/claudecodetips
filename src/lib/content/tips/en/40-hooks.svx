---
id: 40
title: "Hooks"
section: advanced
summary: "Shell commands that run at specific events like edits, tool use, or session start."
isFree: false
---

Hooks are shell commands that run at specific points during Claude's operation. They guarantee certain actions happen every time, rather than hoping Claude remembers to do something.

I use hooks for three things: auto-formatting after every edit, blocking dangerous commands, and getting desktop notifications when Claude needs input. The first two alone have saved me countless annoyances.

## Configuration

[Hooks](https://code.claude.com/docs/en/hooks) live in JSON settings files at three levels:

- `~/.claude/settings.json` - User-level (all projects)
- `.claude/settings.json` - Project-level (team-shared)
- `.claude/settings.local.json` - Local project (gitignored)

Project-level takes precedence over user-level. Run `/hooks` to manage them through Claude's interactive menu.

## The Ten Hook Events

| Event | Trigger | Best Use Cases |
|-------|---------|----------------|
| **PreToolUse** | Before tool executes | Block dangerous commands, validate paths, auto-approve safe ops |
| **PostToolUse** | After tool completes | Auto-format code, run linters, log changes |
| **PermissionRequest** | Before permission dialog | Auto-approve test commands, deny sensitive access |
| **Notification** | Claude sends alerts | Desktop notifications, Slack/ntfy integration |
| **UserPromptSubmit** | Before prompt processing | Inject context, validate prompts, add sprint info |
| **Stop** | Claude finishes responding | Quality gates, force continuation until tests pass |
| **SubagentStop** | Subagent finishes | Validate subagent output |
| **PreCompact** | Before context compaction | Backup transcripts, log decisions |
| **SessionStart** | Session begins/resumes | Load git status, set environment vars |
| **SessionEnd** | Session ends | Cleanup, final logging |

## Basic Configuration

The hook structure: event > matchers > commands.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "prettier --write \"$CLAUDE_FILE_PATHS\"",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

Hooks receive input as JSON via stdin, not just environment variables. Parse it with `jq`:

```bash
#!/bin/bash
INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')
```

## Matcher Patterns

- **Exact**: `"Write"` - matches only Write tool
- **Multiple**: `"Write|Edit"` - matches either (regex OR)
- **Wildcard**: `"*"` or `""` - matches all tools
- **With arguments**: `"Bash(npm test*)"` - matches specific commands
- **MCP tools**: `"mcp__memory__.*"` - matches Model Context Protocol tools

Matchers are case-sensitive. `write` won't match `Write`.

## Exit Codes and Control Flow

Your hook scripts control execution via exit codes:

| Exit Code | Behavior |
|-----------|----------|
| **0** | Success. stdout processed as JSON or added to context |
| **2** | Blocking error. Action prevented, stderr fed back to Claude |
| Other | Non-blocking error. stderr shown in verbose mode, execution continues |

Exit code 2 is the key. Write error messages to **stderr**, not stdout. Claude reads stderr to understand what went wrong and adjust.

```bash
#!/bin/bash
INPUT=$(cat)
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

if [[ "$COMMAND" == *"rm -rf"* ]]; then
  echo "Blocked dangerous command: rm -rf" >&2
  exit 2
fi
exit 0
```

## JSON Output for Fine Control

Return structured JSON to stdout for granular control:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Production file access blocked"
  }
}
```

Since v2.0.10, PreToolUse hooks can modify inputs before execution. This lets you add safety flags without blocking Claude:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow",
    "updatedInput": {
      "command": "rm -i test.txt"
    }
  }
}
```

## Practical Examples

### 1. Auto-Format After Edits

The most useful hook. Run your formatter after every Write or Edit:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "npx prettier --write \"$(cat | jq -r '.tool_input.file_path')\""
          }
        ]
      }
    ]
  }
}
```

### 2. Block Dangerous Commands

Create a validation script and wire it to PreToolUse:

```bash
#!/bin/bash
# validate-bash.sh
INPUT=$(cat)
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

# Block dangerous patterns
if echo "$COMMAND" | grep -qE '(rm -rf /|chmod 777|> /dev/)'; then
  echo "Blocked: $COMMAND" >&2
  exit 2
fi
exit 0
```

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [{ "type": "command", "command": "/path/to/validate-bash.sh" }]
      }
    ]
  }
}
```

### 3. Quality Gate on Stop

Force Claude to keep working until tests pass:

```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [{ "type": "command", "command": "npm run lint && npm test" }]
      }
    ]
  }
}
```

If the command exits with code 2, Claude can't stop. The stderr becomes feedback, and Claude attempts to fix the issues. Be careful with this one. It can create infinite loops if Claude can't fix the problem.

### 4. Desktop Notifications

Get notified when Claude needs input instead of silently waiting:

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "permission_prompt",
        "hooks": [
          {
            "type": "command",
            "command": "terminal-notifier -title 'Claude Code' -message 'Awaiting input' -sound Glass"
          }
        ]
      }
    ]
  }
}
```

Notification matchers: `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`.

### 5. Inject Context at Session Start

Load project state automatically when starting:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "git status --short && echo '---' && cat TODO.md 2>/dev/null || true"
          }
        ]
      }
    ]
  }
}
```

SessionStart hooks have access to `CLAUDE_ENV_FILE`. Write to this file to persist environment variables for the session:

```bash
echo 'export NODE_ENV=production' >> "$CLAUDE_ENV_FILE"
```

## Environment Variables

| Variable | Description | Availability |
|----------|-------------|--------------|
| `CLAUDE_PROJECT_DIR` | Absolute path to project root | All hooks |
| `CLAUDE_CODE_REMOTE` | `"true"` in web environments | All hooks |
| `CLAUDE_ENV_FILE` | File path for persisting env vars | SessionStart only |
| `CLAUDE_FILE_PATHS` | Space-separated file paths from tool | File-related tools |

Input data comes via stdin as JSON. Don't rely solely on environment variables. Some have had reliability issues. Parse stdin with `jq` for consistent results.

## Debugging

1. **Verify registration**: Run `/hooks` to see active hooks
2. **Debug mode**: `claude --debug` shows verbose hook execution
3. **Test manually**: Run your script directly with sample JSON piped to stdin
4. **Check permissions**: `chmod +x your-script.sh`
5. **Disable hooks**: Create a `no-hooks.json` with `{"disableAllHooks": true}` and run `claude --settings no-hooks.json`

Debug output shows the full execution flow:

```
[DEBUG] Executing hooks for PostToolUse:Write
[DEBUG] Found 1 hook matchers in settings
[DEBUG] Matched 1 hooks for query "Write"
[DEBUG] Hook command completed with status 0
```

## Security Considerations

Hooks execute with your user permissions. Treat them as code that runs automatically with full access.

**Do this:**

- Validate and sanitize all inputs from stdin
- Always quote shell variables: `"$VAR"` not `$VAR`
- Check for path traversal (`..` in paths)
- Use absolute paths for scripts
- Skip `.env`, `.git/`, and key files
- Set `set -euo pipefail` at the top of bash scripts

**Protection built in**: Claude Code captures hook config at startup. Direct edits to settings files during a session require review in the `/hooks` menu before taking effect.

## Common Pitfalls

1. **Exit code confusion**: Only exit 2 blocks. Other non-zero codes just log warnings.
2. **stdout vs stderr**: Blocking errors must go to stderr, not stdout.
3. **Hook not firing**: Matchers are case-sensitive. `bash` won't match `Bash`.
4. **Timeouts**: Default is 60 seconds. Set `"timeout": 120` for slow operations.
5. **Stop hook loops**: If your Stop hook always fails, Claude keeps retrying forever.
6. **Parsing JSON**: Use `cat | jq`, not environment variables, for reliable input.
