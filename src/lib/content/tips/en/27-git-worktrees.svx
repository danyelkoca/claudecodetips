---
id: 27
title: "Git Worktrees"
section: multi-agent
summary: "Multiple working directories from same repo. Run Claude in each."
isFree: false
---

Worktrees solve a real problem: you're deep in a feature branch, someone needs an urgent hotfix on main, and you either stash everything (risky), clone the whole repo again (wasteful), or lose your place. [Git worktrees](https://git-scm.com/docs/git-worktree) let you check out multiple branches into separate directories, all sharing one `.git` database.

## Why Worktrees Beat the Alternatives

| Approach | Disk Usage | Context Switching | Parallel Work |
|----------|------------|-------------------|---------------|
| git stash | Minimal | Sequential only | No |
| git clone | High (full repo copy) | Parallel | Yes, but wasteful |
| git worktree | Low (shared .git) | Parallel | Yes, efficient |

Stashes pile up, conflicts happen on pop, and you lose mental context. Multiple clones waste disk space and create divergent histories you have to keep in sync.

Worktrees give you separate folders for each branch, all sharing the same Git history. No stashing, no conflicts, no wasted space.

## Basic Commands

```bash
# Create worktree with new branch
git worktree add ../feature-auth -b feature-auth

# Create worktree from existing branch
git worktree add ../hotfix hotfix-branch

# Create worktree tracking remote branch (new -t flag in Git 2.52+)
git worktree add -t ../feature-api origin/feature-api

# List all worktrees
git worktree list

# Remove a worktree when done
git worktree remove ../feature-auth

# Clean up stale worktree references
git worktree prune
```

The `-t` flag (added in [Git 2.52](https://git-scm.com/docs/git-worktree)) automatically sets up tracking for remote branches, so you don't need a separate `git branch --set-upstream-to` command.

## Bare Repository Setup

For a cleaner directory structure, use a [bare clone](https://morgan.cugerone.com/blog/how-to-use-git-worktree-and-in-a-clean-way/). Instead of the repo root being your working directory, it becomes a container for all your worktrees:

```bash
# Create project directory
mkdir my-project && cd my-project

# Clone as bare repository
git clone --bare git@github.com:user/repo.git .bare

# Create pointer file so git commands work in this directory
echo "gitdir: ./.bare" > .git

# Fix remote fetching (bare clones don't fetch remotes by default)
git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
git fetch origin

# Now create worktrees
git worktree add main origin/main
git worktree add feature-branch -b feature-branch
```

Result:
```
my-project/
├── .bare/              # Git database (hidden)
├── .git                # Pointer file
├── main/               # Worktree: main branch
└── feature-branch/     # Worktree: feature branch
```

This structure is cleaner because your repo root is not a working directory. All branches live as sibling folders. Some developers find this easier to manage when running multiple Claude sessions, each in its own worktree.

## Handling Dependencies

Each worktree is a separate folder. Dependencies are not shared, and gitignored files like `.env` don't transfer automatically. This is the biggest friction point when adopting worktrees.

**The naive approach** is running `npm install` in every new worktree. On large repos, that's 2+ minutes each time. You'll stop using worktrees.

**The fast approach**: use `npm ci` (clean install) which skips dependency resolution:

```bash
cd ../my-app-feature
npm ci
cp ../my-app/.env .
```

**The fastest approach**: copy node_modules directly using copy-on-write (CoW) on macOS/Linux:

```bash
cp -c -r ../my-app/node_modules .  # -c enables CoW on APFS/Btrfs
```

Copy-on-write shares the actual disk blocks until you modify them. 500MB of node_modules copies in under a second.

Automate this with a shell function:

```bash
# In ~/.zshrc or ~/.bashrc
wt() {
  git worktree add "../$1" -b "$1"
  cd "../$1"
  # Copy dependencies if they exist in main worktree
  [ -d "../main/node_modules" ] && cp -c -r ../main/node_modules .
  [ -f "../main/.env" ] && cp ../main/.env .
}
```

Now `wt new-feature` creates a worktree, copies dependencies, and drops you in the new directory ready to work.

## IDE Integration

[VS Code 1.103](https://code.visualstudio.com/updates/v1_103) (July 2025) added native worktree support. Enable it with the `git.detectWorktrees` setting, then:

- **Create**: Command Palette → "Git: Create Worktree" or Source Control → right-click → Worktrees → Create
- **Open**: Right-click worktree → "Open Worktree in New Window"
- **Compare**: Right-click a changed file → "Compare with Workspace"
- **Migrate**: Command Palette → "Migrate Worktree Changes" to merge changes back

The Source Control Repositories view distinguishes between repositories, submodules, and worktrees, showing their relationships visually.

Open each worktree in a separate VS Code window. Each maintains its own IDE state, breakpoints, debug configurations, and terminal sessions. For Claude work, this means you can have one window open with your main branch and another where Claude is working on a feature, switching between them instantly.

## Best Practices

**Directory structure**: Keep worktrees as siblings to your main repo:
```
~/projects/my-app/           # main
~/projects/my-app-feature/   # feature branch
~/projects/my-app-hotfix/    # hotfix branch
```

**Naming convention**: Use `repo-branchname` pattern for clarity. When you have 6 worktrees, knowing which is which matters.

**Merge frequently**: Pull updates from main into worktrees to prevent massive merge conflicts later. A worktree that diverges for 2 weeks becomes a merge nightmare.

## Troubleshooting

**"Branch already checked out" error**: You can't check out the same branch in multiple worktrees. Create a new branch or use a different one.

**Deleted worktree manually?** Run `git worktree prune` to clean up stale references.

**Worktree on portable drive?** Lock it to prevent pruning:
```bash
git worktree lock ../portable-worktree --reason "On external drive"
git worktree unlock ../portable-worktree  # When done
```

**Submodules?** Each worktree needs its own submodule initialization:
```bash
cd ../my-app-feature
git submodule update --init
```

## Performance for Large Repos

For monorepos, enable [Git's file system monitor](https://github.blog/engineering/infrastructure/improve-git-monorepo-performance-with-a-file-system-monitor/). Instead of scanning every file on `git status`, Git asks the OS which files actually changed:

```bash
git config core.fsmonitor true
git config core.untrackedcache true
```

[GitHub's testing](https://github.blog/engineering/infrastructure/improve-git-monorepo-performance-with-a-file-system-monitor/) showed dramatic improvements on large repos:
- Chromium (393K files): 17.6s → 0.8s
- 1M file synthetic repo: 41s → 0.6s

The first run after enabling may be slow (building the cache), but subsequent runs drop to under a second.

If you only work in part of the repo, combine with sparse checkout:

```bash
git sparse-checkout init --cone
git sparse-checkout set src/my-module
```

This checks out only the directories you specify. In a monorepo with 50 services, you might only need 3 of them in a given worktree.

## When Worktrees Make Sense

**Good use cases:**
- Hotfix on main while you're mid-feature on another branch
- Reviewing a PR without losing your current work
- Running a Claude session on a feature while you continue manual work elsewhere
- Keeping a "clean main" worktree for quick reference checks
- Experimenting with a risky refactor without touching your stable branch

**Skip worktrees for:**
- Quick 10-minute fixes (the setup overhead isn't worth it)
- Tightly coupled work where both branches touch the same files (merge conflicts negate the benefit)
- Teams that don't clean up (20 stale worktrees is worse than stash chaos)

## Cleanup Discipline

Worktrees are meant to be ephemeral. Create, work, merge, delete. If your `git worktree list` output grows past 5 entries, you're hoarding.

```bash
# See what you have
git worktree list

# Remove a worktree (deletes the directory too)
git worktree remove ../my-app-feature

# Delete the branch if merged
git branch -d feature-branch

# Clean up stale entries (if you deleted directories manually)
git worktree prune
```

Make worktree cleanup part of your PR merge routine. Merged the PR? Delete the worktree. Otherwise they accumulate like browser tabs you'll "get back to later."
